
<meta charset="utf-8">
<html lang="ko">
<head>
    <link rel="stylesheet" type="text/css" href="./../style.css" />
    <title>객체지향의 기본 요소 5가지</title>
</head>
<body id="tt-body-page" class="">
<div id="wrap" class="wrap-right">
    <div id="container">
        <main class="main ">
            <div class="area-main">
                <div class="area-view">
                    <div class="article-header">
                        <div class="inner-article-header">
                            <div class="box-meta">
                                <h2 class="title-article">객체지향의 기본 요소 5가지</h2>
                                <div class="box-info">
                                    <p class="category">programming</p>
                                    <p class="date">2021-03-05 23:11:23</p>
                                </div>
                            </div>
                        </div>
                    </div>
                    <hr>
                    <div class="article-view">
                        <div class="contents_style">
                            <p><i><b>1. 객체(Object)</b></i></p>
<p>&nbsp; 현실에서의 객체는 사람이 인식할 수 있는 최소한의 의미를 가지며 세상에서 유일한 실체가 있는 사물이다. 즉, 객체는 사람이 인식할 수 있는 최소한의 의미를 갖고, 유일하고, 실존하는 사물이다.</p>
<p>&nbsp; 객체지향 소프트웨어를 구현할 때는 속성과 기능이 필요하다. 객체는 이 두가지 요소를 모두 갖추었기에 객체지향 소프트웨어에서 최소한의 독립 단위로의 의미를 가진다. 따라서 객체지향에서의 객체는 데이터와 기능을 모두 갖춘 독립적으로 실행할 수 있는 최소한의 독립적인 단위이다. 이때 객체는 객체지향 소프트웨어에서 유일한 실체로 존재한다.</p>
<p>&nbsp;</p>
<p><i><b>2. Class</b></i></p>
<p><b>&nbsp;&nbsp;</b>객체는 구체적이고 클래스는 추상적이다</p>
<p>&nbsp; 외연: 일정한 개념에 속하는 모든 객체들의 집합</p>
<p>&nbsp; 종개념: 하나의 개념 속에 포함되 있는 여러 개의 개별개념</p>
<p>&nbsp; 분류: 개념의 외연에 포함되는 종개념을 명확하게 구분해 체계적으로 정리한것</p>
<p>&nbsp; 범주: 동일한 성질을 가진 사물을 하나의 단어로 묶은것</p>
<p>&nbsp; 따라서 분류는 종류별로 구분해 체계적이고 계층적으로 정리한 Tree와 같고, 범주는 분류의 상세 목록에 해당하는 Node명이다.</p>
<p>&nbsp; 범주와 분류를 사용하면 사물을 같은 기준으로 묶어서 단순하게 표현된다. 따라서 추상화에 도움이 된다.&nbsp;</p>
<p>&nbsp; 객체지향에서의 클래스는 코드로 작성한 설계도이고 클래스 코드를 바탕으로 실제로 생성해 메모리에 올라가면 객체가 된다.</p>
<p><i><b>3. 속성(Attribute)</b></i></p>
<p><b>&nbsp;&nbsp;</b>속성은 객체가 가지고 있는 고유 값이다, 또는 변수라 한다.</p>
<p>&nbsp; 속성을 잘 추출하기 위해서는 객체 하나만 생각하지 말고 객체 간의 협력관계를 생각해야 한다. 객체간의 협력관계에서는 속성보다는 메서드를 더 의식하게 되는데 이는 메서드가 다른 객체와 상호작용을 하는 관문이기 때문이다. 속성은 '객체가 주어진 역할을 최대한 잘 수행하기 위해서, 어떤 기능이 필요할까?'라는 관점에서 점근을 해야한다. 즉, 소프트웨어에서 객체가 최대한 기능을 잘 발휘할 수 있는 관점에서 어떤 속성이 필요한지를 찾아야 한다.</p>
<p><i><b>4. 메서드(Method)</b></i></p>
<p>&nbsp; 메서드를 단순하게 함수 정도로만 생각하는 사람들이 있지만 사실 객체지향에서의 메서드는 절차지향에서의 함수보다 더 많은 의미를 지니고 있다. 메서드를 제대로 사용하기 위해서는 다음과 같은 것들을 이해해야 한다.</p>
<p>&nbsp;<b> &nbsp; 1. 처리, 판단, 반복문은 기본적으로 활용할 줄 안다.</b></p>
<p><b>&nbsp; &nbsp; 2. 함수 개념을 활용하여 반복되는 로직을 함수 안에 집어넣고 호출해 쓸 줄 안다</b></p>
<p><b>&nbsp; &nbsp; 3. 객체를 만들 때 속성과, 객체에 필요한 기능이 무엇인지 고려하면서 메소드를 작성한다. 즉 로직 관점이 아닌, 객체 설계 관점으로 넓은 시야를 가진다.</b></p>
<p><b>&nbsp; &nbsp; 4. 캡슐화를 지키려고 한다. 캡슐화를 왜 해야 하는지 안다. 속성은 다른 객체가 접근하지 못하게 private으로 선언하고, 메서드로만 접근하도록 구성할 줄 안다.</b></p>
<p><b>&nbsp; &nbsp; 5. 점(각각의 객체)보다는 선(객체 간의 협력관계)으로 접근할 줄 안다.</b></p>
<p>&nbsp;</p>
<p>&nbsp; 1, 2는 함수의 개념이니 넘어가고 3~5에 대한 자세한 설명을 하자면</p>
<p><b>&nbsp; 3.<span style="color: #333333;">객체를 만들 때 속성과, 객체에 필요한 기능이 무엇인지 고려하면서 메소드를 작성한다. 즉 로직 관점이 아닌, 객체 설계 관점으로 넓은 시야를 가진다.</span></b></p>
<p>&nbsp; &nbsp; 객체지향에서는 하나의 객체를 크게 속성과 행동으로 나눈다. 객체지향에서 행동은 메서드로 표현된다. 메서드는 객체가 자신 또는 다른 객체에세 제공하는 기능이다. 따라서 메서드는 객체가 외부에 제공하는 행동을 적절한 문장으로 정의하고, 그 기능을 코드로 구현한 결과물이다.&nbsp;</p>
<p>&nbsp; 로직 관점은 단순히 주어진 문제를 해결하는데 집중해 로직 단위로 사고하면서 메서드를 작성하는 것이고, 객체 설계관점은 객체가 제 역할을 수행할 때 필요한 기능은 무엇일까 생각하는 관섬에서 메서드를 작성하는 것이다.</p>
<p><b><span>&nbsp;</span>4. 캡슐화를 지키려고 한다. 캡슐화를 왜 해야 하는지 안다. 속성은 다른 객체가 접근하지 못하게 private으로 선언하고, 메서드로만 접근하도록 구성할 줄 안다.</b></p>
<p>&nbsp; 메서드는 객체의 속성을 변경하는 통로이다. 객체지향이 추구하는 가이드를 따르면, 속성은 외부로부터의 접근이 차단되야 한다. 속성은 오직 메서드를 통해서만 접근이 가능하기 때문이다. 이 규칙을 캡슐화라한다. 따라서 메서드는 객체의 속성을 변경하는 통로 역할을 수행해야 한다. 그러므로 속성은 외부 객체가 접근하지 못하게 하고, 가능한 메서드를 통해서만 접근하도록 개발해야 한다. 이런 캡슐화 규칙을 통해 객체의 무결성과 안전성을 강화할 수 있다.&nbsp;</p>
<p><b>&nbsp; 5. 점(각각의 객체)보다는 선(객체 간의 협력관계)으로 접근할 줄 안다.</b></p>
<p>&nbsp; &nbsp;객체의 속성이 은밀하고 수동적이라면 메서드는 적극적이고 능동적이다. 메서드는 다른 객체에서 자신이 제시하는 기능을 쓰라고 노출하기 때문에 적극적이다. 객체들끼리 메시지를 주고받으면서 소프트웨어의 결과에 영향을 주기때문에 능동적이다. 메서드는 객체들 끼리 메시지를 주고받는 통로이다.&nbsp;</p>
<p>&nbsp; &nbsp; 다른 객체가 속성에 접근하는 것을 차단하고 메서드를 통해 속성에 접근한다는 캡슐화 원칙을 지켰다면 협력에 특화된 메서드의 특징이 잘 드러난다. 메서드는 다른 객체와 상호작용하는 통로이므로 메서드를 설계할 때는 메서드가 속한 객체 하나만 염두에 두고 구성을 하는것 보다는 다른 객체와 어떻게 상호작용하면 더 좋을지를 기준으로 접근해야 한다.</p>
<p>&nbsp;</p>
<p><i><b>5. 생성자(Constructor)</b></i></p>
<p><b>&nbsp;&nbsp;</b>객체의 생명주기에서 생성자는 객체의 생성과 관련된 요소이다. 생성자는 객체가 최초에 생성될 때 호출되는 일종의 메서드이다. 그래서 객체가 처음 생성될때 객체가 어떤 일을 해야 한다면 생성자에서 구현한다. 이 경우 경우에 따라 여러 생성자가 필요할 수 있다. 이때는 생성자의 파라미터를 다르게 주어서 같은 이름의 생성자를 호출하는 오버로딩을 사용하면 된다.</p>
<p>&nbsp;</p>
<p>출처 - 한번 읽으면 두번 깨닫는 객체지향 프로그래밍</p>
                        </div>
                        <br/>
                        <div class="tags">
                            #OOP #객체지향 프로그래밍 
                        </div>
                    </div>
                    
                </div>
            </div>
        </main>
    </div>
</div>
</body>
</html>
