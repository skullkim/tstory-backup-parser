
<meta charset="utf-8">
<html lang="ko">
<head>
    <link rel="stylesheet" type="text/css" href="./../style.css" />
    <title>DDD(Domain Driven Development)</title>
</head>
<body id="tt-body-page" class="">
<div id="wrap" class="wrap-right">
    <div id="container">
        <main class="main ">
            <div class="area-main">
                <div class="area-view">
                    <div class="article-header">
                        <div class="inner-article-header">
                            <div class="box-meta">
                                <h2 class="title-article">DDD(Domain Driven Development)</h2>
                                <div class="box-info">
                                    <p class="category">programming</p>
                                    <p class="date">2022-05-20 16:21:55</p>
                                </div>
                            </div>
                        </div>
                    </div>
                    <hr>
                    <div class="article-view">
                        <div class="contents_style">
                            <p data-ke-size="size16">&nbsp; 좋은 소프트웨어를 만들기 위해선 소프트웨어가 동작하는 도메인에 집중해야 한다. 소프트웨어의 목적은 특정 도메인에 대한 프로세스를 자동화하는 것이다. 이를 위해선 도메인과 소프트웨어가 조화를 이루어야 한다. 이를 위해 소프트웨어는 도메인을 반영해야 한다. 즉, 소프트웨어는 도메인을 모델링해야 한다.</p>
<p data-ke-size="size16">&nbsp; 도메인은 현실 세계에 존재하는 무언가 이다. 도메인을 소프트웨어에 반영하기 위해선 도메인을 추상화해야 한다. 여기서 추상화란 도메인을 표현한 모델이다. 모델은 대상 도메인에 대한 내부적 표현으로 소프트웨어 설계에 필수적인 요소다. 인간의 인지 능력을 극복하기 위해선 모델(추상화)이 필요하고 도메인에 대한 사고 활동은 모델로 통합된다.</p>
<h3 data-ke-size="size23"><b>Ubiquitos Language</b></h3>
<p data-ke-size="size16"><b>&nbsp;&nbsp;</b>개발자와 도메인 전문가가 협업할 때 둘이 사용하는 용어의 차이로 인해 근본적인 어려움을 격는다. 따라서 모델을 만들 때 모델의 구성 요소와 같은 세부적인 것들에 대해 정보를 교환해야 하며 이를 통해 도메인에 대해 토의할 수 있는 공통된(ubiquitos) 언어를 만들어야 한다.</p>
<p data-ke-size="size16">&nbsp; 도메인 주도 설계의 핵심 원칙은 모델 기반의 언어를 사용하는 것이다. 모델은 소프트웨어와 도메인이 서로 교차하는 지점이기 때문에 모델 기반 언어를 사용하는 것이 가장 적절하다(도메인 전문가와 개발자의 전문 분야 중간에 속하는 지점이 모델이다).</p>
<p data-ke-size="size16">&nbsp; 도메인을 기반한 언어가 정해졌다면, 이 언어를 코드, 다이어그램, 회의 등 모든 곳에 활용하라.</p>
<h3 data-ke-size="size23"><b>Model Driven Design</b></h3>
<p data-ke-size="size16">&nbsp; 도메인을 최고의 모델로 추상화하는 것은 소프트웨어 개발에 있어서 아주 중요한 요소다. 하지만, 최고의 모델을 만들어 냈어도 이를 코드로 바꾸지 못한다면, 신뢰할 수 없는 소프트웨어가 만들어진다.</p>
<p data-ke-size="size16">&nbsp; 도메인 전문가와 소프트웨어 분석가가 함께 만든 모델을 코드로 변환하고자 할 때, 개발자는 해당 모델을 완벽히 코드로 변환할 수 없다는 사실을 발견할 수 있다. 이는 도메인 전문가가 개발에 대한 이해 없이 모델을 생성했기 때문이다. 이런 상황에서 개발자들은 동작하는 소프트웨어를 만들기 위해 그들만의 생각을 추가해 모델을 변경할 것이다. 시간이 흐르고 요구사항이 추가되거나 변경된다면 도메인 전문가가 설계하는 모델과 개발자가 생각하는 방향에는 더 큰 차이가 발생한다. 개발자는 요구사항을 이해하기 위해 더 많은 시간을 쓰게 된다. 만약 개발자와 도메인 전문가가 같은 회의에 참석해 코드를 설계하기 전 도메인과 모델을 명확하고 완전하게 이해한다면 훨씬 생산적일 것이다.</p>
<p data-ke-size="size16">&nbsp; 도메인 모델링과 설계를 밀접히 연관시켜라. 설계가 직관적이면서 모델을 기반으로 수행될 수 있게 소프트웨어로 정확히 표현될 수 있는 모델을 선택해야 한다. 코드와 코드의 기반이 되는 모델을 밀접히 연관시켜 코드엔 의미가 생기고 모델은 실질적으로 중요한 가치를 지니게 된다.</p>
<h3 data-ke-size="size23"><b>The Building Blocks Of A Model-Driven Design</b></h3>
<p data-ke-size="size16"><b>&nbsp;&nbsp;</b>아래에서 소개할 패턴들은 DDD에서 사용되는 주요 패턴들이다. 이 패턴들은 객체 모델링, 소프트웨어 설계의 핵심 요소들을 보여준다. 아래 다이어그램은 이 패턴들의 관계다.</p>
<p><figure class="imageblock alignCenter" width="658" height="473" >
    <span data-lightbox="lightbox">
        <img src="./img/img.png" width="658" height="473"  />
    </span>
    <figcaption></figcaption>
</figure></p>
<h4 data-ke-size="size20"><b>Layered Architecture</b></h4>
<p data-ke-size="size16">&nbsp; 아래의 그림과 같이 각 레이어가 서로 얽혀 있다면 코드를 이해하기 어렵고, 한 곳에서 발생한 변화가 곳곳으로 퍼지게 된다.</p>
<p><figure class="imageblock alignCenter" width="615" height="357" >
    <span data-lightbox="lightbox">
        <img src="./img/img_1.png" width="615" height="357"  />
    </span>
    <figcaption></figcaption>
</figure></p>
<p data-ke-size="size16">&nbsp; &nbsp; 따라서 레이어를 명확히 나눠야 하며 각 레이어 내부에서 설계를 수행해 응집도 높고 자기 하위 레이어에만 의존하게 만들어야 한다. 또한 상위 레이어에 대한 결합돌르 낮추려면 표준적인 아키텍처 패턴을 따라야 한다. 하나의 레이어에 도메인과 관련된 모든 코드를 집중시켜서 다른 레이어로 부터 고립시켜야 한다.</p>
<p data-ke-size="size16">&nbsp; DDD의 아키텍처는 다음과 같은 4개의 개념적 레이어를 포함한다.</p>
<table style="border-collapse: collapse; width: 100%;" border="1" data-ke-align="alignLeft">
<tbody>
<tr>
<td style="width: 50%;">Presentation Layer</td>
<td style="width: 50%;">사용자에게 정보를 보여주고 사용자의 명령을 해석한다.</td>
</tr>
<tr>
<td style="width: 50%;">Application Layer</td>
<td style="width: 50%;"><span style="color: #666666;">도메인간 상호작용을 관여한다. 비즈니스 로직을 포함하지 않고, 비즈니스 객체의 상태 역시 유지되지 않는다.하지만, 애플리케이션 작업 상태는 유지할 수 있다. 애플리케이션의 작업 전반을 감독하고 조율하는 관리 비즈니스 로직이 존재한다.</span></td>
</tr>
<tr>
<td style="width: 50%;">Domain Layer</td>
<td style="width: 50%;">도메인 정보를 포함하며 소프트웨어의 핵심이다. 비즈니스 객체의 상태를 포함하지만 상태의 영속성은 Infrastructure Layer가 담당한다.</td>
</tr>
<tr>
<td style="width: 50%;">Infrastructure Layer</td>
<td style="width: 50%;">다른 레이어 모두를 지원하는 라이브러리다. 레이어 간의 통신을 제공하고 비즈니스 객체의 영속성을 구현하고 사용자 인터페이스 레이어의 라이브러리를 포함한다.&nbsp;</td>
</tr>
</tbody>
</table>
<p data-ke-size="size16">&nbsp; 애플리케이션을 여러 개의 계층으로 나누고 각 레이어는 상호작용해야 한다. 그렇지 않다면 변경에 용이하지 못한 구조가 되어 변경의 영향이 곳곳에 퍼지게 된다. 도메인 계층에는 오직 핵심 도메인만 존재해야 한다. UI는 비즈느스 로직 또는 infrastructure 계층에 해야할 일과 결합되 있지 말아야 한다.</p>
<h4 data-ke-size="size20"><b>Entity</b></h4>
<p data-ke-size="size16"><b>&nbsp;&nbsp;</b>소프트웨어가 여러 상태를 거치는 동안 동일한 값을 유지하는 식별자를 지니는 객체다. 엔티티의 식별자는 한개 이상의 속성을 조합해 사용한다. 시스템이 쉽게 구분할 수 있는 식별자를 만들어야 한다. 시스템은 식별자가 같은 두 객체는 같다고 간주하므로, 이를 지키지 못하면 전체 시스템이 오류에 빠진다.</p>
<p data-ke-size="size16">&nbsp; 객체의 식별자는 모듈에 의해 자동 생성되는 ID나 DB 테이블의 PK 등을 사용할 수 있다.</p>
<p data-ke-size="size16">&nbsp; 객체가 식별자에 의해 식별된다면, 모델의 해당 객체 정의에 이 식별자가 반영되야 한다. 이떄 클래스의 정의를 단순하게 유지하고 생명주기의 연속성과 식별자에 초점을 맞춰야 한다.</p>
<p data-ke-size="size16">&nbsp; 엔티티는 도메인 모델에서 매우 중요한 객체들이다. 모델링 작업을 시작할 때부터 고민하고, 어떤 객체를 엔티티로 봐야 할지 결정해야 한다.</p>
<h4 data-ke-size="size20"><b>Value Object</b></h4>
<p data-ke-size="size16"><b>&nbsp; &nbsp;&nbsp;</b>엔티티는 식별자를 생성과 추적에 대한 비용이 든다. 식별자를 추적하는 일은 어렵다. 잘못된 결정으로 인해 여러 객체가 동일한 식별자를 가지면 예상치 못한 결과가 초래된다. 따라서 객체 자체가 아닌 객체가 가지는 속성에만 관심이 있다면, 즉, 객체가 도메인의 어떤 측면을 표현하는 데 사용되지만 식별자가 없다면, VO를 사용하면 된다.</p>
<p data-ke-size="size16">&nbsp; 엔티티 정의에 부합하는 객체만을 엔티티로 정의하고, 나머지는 VO로 만들라. VO는 식별자 생성과 관련 없고, 더이상 참조되지 않는다면 GC가 알아서 소멸시킨다. 따라서 VO의 사용이 설계를 더 단순화 한다.</p>
<p data-ke-size="size16">&nbsp; VO는 불변이어야 한다. 데이터 무결성을 지켜야 의도치 않은 에러를 없애 공유될 수 있다.</p>
<p data-ke-size="size16">&nbsp; VO는 다른 객체나 엔티티들의 참조를 가질 수 있다. VO는 도메인 객체의 속성들을 담기 위해 사용되지만, 모든 정보를 나열해야 한다는 의미는 아니다. 속성들을 서로 다른 객체로 그룹핑하고 이들이 VO를 구성하게 할 수 있다.</p>
<h4 data-ke-size="size20"><b>Service</b></h4>
<p data-ke-size="size16">&nbsp; 도메인을 분석하고 모델을 구성하는 주요 객체를 정의하다 보면 어느 객체에도 속하기 애매한 행위들이 존재한다. 이런 행위들을 임의의 ㄷ도매인 객체에 넣거나 엔티티, VO에 넣는다면 객체를 망치게 된다. 이런 행위는 여러 객체에 걸처서 동작한다. 이 문제를 해결하는 가장 좋은 방법은 서비스를 정의하는 것이다. 서비스는 상태를 가지지 않고 도메인에 기능을 제공하는 목적을 지닌다.</p>
<p data-ke-size="size16">&nbsp; 서비스는 객체 자신이 아닌 오퍼레이션이 수행되는 대상이나, 목적이 되는 객체와 관련있다. 따라서 서비스는 많은 객체와 관계를 맺는 지점이다.</p>
<p data-ke-size="size16">&nbsp; 서비스는 다음과 같은 특징을 갖는다.</p>
<p data-ke-size="size16">&nbsp; &nbsp; 1. 서비스에 의해 수행되는 오퍼레이션은 일반적으로 엔티티 또는 VO에 속할 수 없는 도메인의 개념을 나타낸다.</p>
<p data-ke-size="size16">&nbsp; &nbsp; 2. 수행되는 오퍼레이션은 도메인의 다른 객체를 참조한다.</p>
<p data-ke-size="size16">&nbsp; &nbsp; 3. 오퍼레이션은 상태를 저장하지 않는다(stateless).</p>
<p data-ke-size="size16">&nbsp; 서비스의 오퍼레이션이 개념적으로 도메인에 속한다면 도메인 레이어에, 애플리케이션 레이어에 속한다면 애플리케이션 레이어에 속해야 한다.</p>
<h4 data-ke-size="size20"><b>Aggregate</b></h4>
<p data-ke-size="size16">&nbsp; Aggregate, repository, factory는 객체 생명주기를 다룬다. 도메인 객체는 생명주기 동안 여러 상태를 거친다. 생성되어 메모리에 올라간뒤, 계산에 사용되고, 소멸된다. 일부 상태의 경우 다시 조회할 수 있게 DB같은 영구적인 곳에 저장된다. 만약 도메인 객체의 생명주기가 올바르게 관리되지 않는다면 모델 전체에 부정적인 영향을 줄 수 있다. 따라서&nbsp; 객체 생명주기를 잘 관리하기 위해 패턴을 사용한다.</p>
<p data-ke-size="size16">&nbsp; Aggregate는 객체의 소유권과 경계를 정의하는 데 사용된다. Factory와 Repository는 객체의 생성과 저장을 도와주기 위한 설계 패턴이다.</p>
<p data-ke-size="size16">&nbsp; 하나의 모델은 많은 도메인 객체를 포함한다. 이 객체들은 서로 연관되 있고 이런 연관 관계에는 몇가지 유형이 있다.</p>
<p data-ke-size="size16">&nbsp; 모델을 단순하고 쉽게 만드는 것이 중요하다. 따라서 도메인 객체 간의 관계들이 불필요하다면 제거해야 한다.</p>
<p data-ke-size="size16">&nbsp; 일대다 관계라면 한 객체가 다른 객체의 집합과 관례를 가지는 것으로 단순화할 수 있다.</p>
<p data-ke-size="size16">&nbsp; 다대다 관계라면 관계에 참여하는 객체의 숫자(다수성-multiplicity)를 최소화 해야 한다. 이를 위헤 모델의 핵심 사항이 아니면 그 관계를 제거해야 한다. 또 한,&nbsp; 다수성의 숫자는 제약사항(constraint)을 추가해 감소시켜야 한다. 만약 제약 조건이 올바르면 제약 조건이 부과된 단 하나의 관계로 표현할 수 있다. 마지막으로 많은 경우 양방향 관계는 단방향으로 대체될 수 있다.</p>
                        </div>
                        <br/>
                        <div class="tags">
                            
                        </div>
                    </div>
                    
                </div>
            </div>
        </main>
    </div>
</div>
</body>
</html>
